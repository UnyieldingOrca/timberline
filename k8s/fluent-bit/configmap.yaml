apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: timberline
  labels:
    app: fluent-bit
data:
  fluent-bit.yaml: |
    service:
      flush: 5
      daemon: off
      log_level: info
      parsers_file: parsers.yaml
      http_server: on
      http_listen: 0.0.0.0
      http_port: 2020
      storage.metrics: on
      grace: 30
      health_check: on
      hc_errors_count: 5
      hc_retry_failure_count: 5
      hc_period: 60

    pipeline:
      inputs:
        - name: tail
          path: /var/log/containers/*.log
          path_key: filename
          parser: docker
          tag: kube.*
          refresh_interval: 5
          rotate_wait: 30
          mem_buf_limit: 5MB
          skip_long_lines: on
          skip_empty_lines: on
          read_from_head: false

      filters:
        - name: kubernetes
          match: kube.*
          k8s-logging.parser: on
          k8s-logging.exclude: off
          annotations: off
          labels: on
          merge_log: off
          keep_log: on
          buffer_size: 256k
          kube_url: https://kubernetes.default.svc:443
          kube_ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          kube_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
          kube_tag_prefix: kube.var.log.containers.
          use_kubelet: on
          kubelet_port: 10250

        - name: record_modifier
          match: '*'
          record: source fluent-bit

        - name: lua
          match: '*'
          script: /fluent-bit/etc/sampling.lua
          call: subsample_info

      outputs:
        - name: http
          match: '*'
          host: log-ingestor
          port: 8080
          uri: /api/v1/logs/stream
          format: json_lines
          header: Content-Type application/x-ndjson
          retry_limit: 1
          workers: 1
          net.keepalive: on
          net.keepalive_idle_timeout: 30

  sampling.lua: |
    function subsample_info(tag, timestamp, record)
        local log_message = record["log"] or record["message"] or ""
        local log_lower = string.lower(log_message)

        -- Always keep ERROR, FATAL, WARN, PANIC logs
        if string.match(log_lower, "error") or
           string.match(log_lower, "fatal") or
           string.match(log_lower, "warn") or
           string.match(log_lower, "panic") then
            return 1, timestamp, record
        end

        -- For INFO/DEBUG logs, sample at 50%
        if string.match(log_lower, "info") or
           string.match(log_lower, "debug") then
            -- Sample 50% (keep 1 out of 2)
            if math.random(2) == 1 then
                return 1, timestamp, record
            else
                return -1, timestamp, record  -- Drop the record
            end
        end

        -- Keep logs without level indicators at 50% as well
        if math.random(2) == 1 then
            return 1, timestamp, record
        else
            return -1, timestamp, record
        end
    end

  parsers.yaml: |
    parsers:
      - name: docker
        format: json
        time_key: time
        time_format: '%Y-%m-%dT%H:%M:%S.%L'
        time_keep: on
        decode_field_as: json log

      - name: syslog
        format: regex
        regex: '^\<(?<pri>[0-9]+)\>(?<time>[^ ]* {1,2}[^ ]* [^ ]*) (?<host>[^ ]*) (?<ident>[a-zA-Z0-9_\/\.\-]*)(?:\[(?<pid>[0-9]+)\])?(?:[^\:]*\:)? *(?<message>.*)$'
        time_key: time
        time_format: '%b %d %H:%M:%S'